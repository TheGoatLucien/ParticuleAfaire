game.c:
#include "game.h"
#include "textureManager.h"
#include "viewManager.h"
#include "stateManager.h"
#include "soundManager.h"
#include "Gamepad.h"
#include "pause.h"
#include "particulesManager.h"

#include <Windows.h>

//sfSprite* sprite;
sfSprite* spBG1;
sfSprite* spBG2;

sfBool gamepadChangePos;
sfVector2f BG1Pos;
sfVector2f BG2Pos;

float timer;
int nbreJoueur;
int waveCount;

float waveTimer;
float soloTimer;
float defaultwaveTimer;
float defaultsoloTimer;
float bossTimer;

sfBool phaseWave;
sfBool phaseBoss;
sfBool phaseBossCompleted;
sfBool gameover;



void initGame(Window* _window)
{
    Texture_Onload(GAME);
    Sound_Onload(GAME); // Charger les sons pour le jeu
    Particle_Onload(GAME); // Charger les particules pour le jeu
    // Jouer la musique de fond
    sfMusic* gameMusic = GetMusic("game_theme");
    if (gameMusic) {
        sfMusic_setLoop(gameMusic, sfTrue);
        sfMusic_play(gameMusic);
    }

    spBG1 = sfSprite_create();
    spBG2 = sfSprite_create();

    sfSprite_setTexture(spBG1, GetTexture("BG1"), sfTrue);
    sfSprite_setTexture(spBG2, GetTexture("BG2"), sfTrue);

    sfSprite_setPosition(spBG2, vector2f(0.0f, -1080.0f));

    sfVector3f ambientLight = { 0.1f, 0.1f, 0.3f };

    BG1Pos = vector2f(0.0f, 0.0f);
    BG2Pos = vector2f(0.0f, -1080.0f);

    SetViewPosition(mainView, vector2f(960.f, 540.f));

    GamepadDetection();

    Sleep(2000); // A enlever juste pour le test Thread

    w.state = sfTrue;

}

void updateGame(Window* _window)
{
    //joue la music

    timer += getDeltaTime();
    Particle* current = particleBegin;
    while (current != NULL) {
        // Mettre à jour la position en fonction de la vélocité
        current->position.x += current->velocity.x * getDeltaTime();
        current->position.y += current->velocity.y * getDeltaTime();
        sfSprite_setPosition(current->sprite, current->position);

        // Réduire la durée de vie
        current->lifetime += getDeltaTime();
        if (current->lifetime >= current->maxLifetime) {
            current = RemoveParticle(current); // Supprimer la particule expirée
        }
        else {
            current = current->pNext;
        }
    }

    // oncréer des particules d'explosion
    if (sfKeyboard_isKeyPressed(sfKeySpace)) {
        Particle* explosionParticles = GetParticle("explosion_particles");
        if (explosionParticles) {
            explosionParticles->position = (sfVector2f){ 500.0f, 500.0f };
            explosionParticles->velocity = (sfVector2f){ 0.0f, -100.0f }; // Mouvement vers le haut
            explosionParticles->lifetime = 0.0f; // Réinitialiser la durée de vie
        }
    }
    for (int i = 0; i < 8; i++)
    {
        if (Gamepad_isButtonPressed(i, OPTION) && timer > 0.2f)
        {
            sfSound* clickSound = GetSound("menu_select");
            if (clickSound)
                sfSound_play(clickSound);
            togglePause();
            timer = 0.0f;
        }
    }

    if (sfKeyboard_isKeyPressed(sfKeyEscape) == sfTrue && timer > 0.2f)
    {
        sfSound* clickSound = GetSound("menu_select");
        if (clickSound)
            sfSound_play(clickSound);
        togglePause();
        timer = 0.0f;
    }

    gamepadChangePos = sfFalse;

    BG1Pos.y = BG1Pos.y + 100.f * getDeltaTime();
    BG2Pos.y = BG2Pos.y + 100.f * getDeltaTime();
    if (BG1Pos.y >= 1080.0f)
        BG1Pos.y = BG2Pos.y - 1080.0f;
    if (BG2Pos.y >= 1080.0f)
        BG2Pos.y = BG1Pos.y - 1080.0f;

    sfSprite_setPosition(spBG1, BG1Pos);
    sfSprite_setPosition(spBG2, BG2Pos);
}

void displayGame(Window* _window)
{
    sfRenderWindow_drawSprite(_window->renderWindow, spBG1, NULL);
    sfRenderWindow_drawSprite(_window->renderWindow, spBG2, NULL);
	//afficher les parti

     // affichage des particules
    Particle* current = particleBegin;
    while (current != NULL) {
        sfRenderWindow_drawSprite(_window->renderWindow, current->sprite, NULL);
        current = current->pNext;
    }
}

void deinitGame()
{
    deinitPause();
    sfSprite_destroy(spBG1);
    sfSprite_destroy(spBG2);
    RemoveAllTextureButALL();
    RemoveAllSoundButALL(); // Libérer les sons du jeu
    RemoveAllParticleButALL();  // Libérer les particules du jeu
}

particuleManager.c:
#include "particulesManager.h"
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

// Charge des particules pour un état dejeu
void Particle_Onload(State _state) {
    particleBegin = NULL; // initialiser la liste des particules a 0

    ressources* tempRessources = ResBegin; // parcourir les ressources chargées
    while (tempRessources != NULL) {
        if (tempRessources->state == _state) {
            Particle* tempParticle = (Particle*)calloc(1, sizeof(Particle));
            strcpy(tempParticle->name, tempRessources->name);
            tempParticle->type = tempRessources->type;
            tempParticle->state = tempRessources->state;


			if (tempRessources->type == PARTICLE) {
				// Charger la texture des particules
				tempParticle->texture = sfTexture_createFromFile(tempRessources->path, NULL);
				if (!tempParticle->texture) {
					printf("Erreur : Impossible de charger la texture des particules %s\n", tempRessources->path);
					free(tempParticle);
					tempRessources = tempRessources->pNext;
					continue;
				}
                //cree le sprute
                tempParticle->sprite = sfSprite_create();
                sfSprite_setTexture(tempParticle->sprite, tempParticle->texture, sfTrue);

                // Initialiser les propriétés par défaut
                tempParticle->position = (sfVector2f){ 0.0f, 0.0f };
                tempParticle->velocity = (sfVector2f){ 0.0f, 0.0f };
                tempParticle->lifetime = 0.0f;
                tempParticle->maxLifetime = 5.0f;

				// ajouter la particule à la liste
				AddParticle(tempParticle);
				
			}

           
        }
        tempRessources = tempRessources->pNext;
    }
}

// Récupérer une particule par son nom
Particle* GetParticle(char* _name) {
    Particle* tempParticle = particleBegin;
    while (tempParticle != NULL) {
        if (strcmp(_name, tempParticle->name) == 0) {
            return tempParticle;
        }
        tempParticle = tempParticle->pNext;
    }
    return NULL;
}

// Ajouter une particule à la liste
void AddParticle(Particle* _particle) {
    _particle->pNext = particleBegin;
    particleBegin = _particle;
}

// Supprimer une particule spécifique
Particle* RemoveParticle(Particle* _particle) {
    if (_particle == particleBegin) {
        Particle* next = _particle->pNext;
        sfTexture_destroy(_particle->texture);
        sfSprite_destroy(_particle->sprite);
        free(_particle);
        particleBegin = next;
        return next;
    }
    else {
        Particle* current = particleBegin;
        while (current->pNext != _particle) {
            current = current->pNext;
        }
        current->pNext = _particle->pNext;
        sfTexture_destroy(_particle->texture);
        sfSprite_destroy(_particle->sprite);
        free(_particle);
        return current->pNext;
    }
}

// Supprimer toutes les particules
void RemoveAllParticle() {
    while (particleBegin != NULL) {
        RemoveParticle(particleBegin);
    }
}

// Supprimer toutes les particules sauf celles associées à ALL
void RemoveAllParticleButALL() {
    Particle* current = particleBegin;
    while (current != NULL) {
        if (current->state != ALL) {
            current = RemoveParticle(current);
        }
        else {
            current = current->pNext;
        }
    }
}

particuleManager.h:
#pragma once
#include "ressourcesManager.h"


typedef struct Particle Particle;
struct Particle {
    Particle* pNext;          // * vers la prochaine particule comme les listes
    char name[30];            // Nom unique de la particule
    ressourceType type;       // type de ressource (SINGLE, SPRITESHEET, etc.)
    State state;
    sfSprite* sprite;          // Sprite de la particule
    sfTexture* texture;        // Texture associée
	sfVector2f position;       // Position de la particule
	sfVector2f velocity;       // Vitesse de la particule
	float lifetime;            // Durée de vie de la particule
	float maxLifetime;         // Durée de vie maximale de la particule
};

Particle* particleBegin;       // debut liste des particules

// fonctionnalités principales
void Particle_Onload(State _state);
Particle* GetParticle(char* _name);
void AddParticle(Particle* _particle);
Particle* RemoveParticle(Particle* _particle);
void RemoveAllParticle();
void RemoveAllParticleButALL();

